<html>
<head>
  <title>Snake with fin-chains</title>
</head>
<body>
  <canvas id="glCanvas" width="400" height="400" style="width: 400px; height: 400px;"></canvas>

  <!-- Vertex shader -->
  <script id="vertex-shader" type="notjs">
    #version 300 es
    in vec2 pos;
    void main() {
      gl_Position = vec4(pos, 0.0, 1.0);
    }
  </script>

  <!-- Fragment shader -->
  <script id="fragment-shader" type="notjs">
    #version 300 es
    precision mediump float;

    #define MAX_SEGMENTS 512

    uniform vec2  u_mouse;          // 頭の位置 (0〜1)
    uniform vec2  u_dir;            // 進行方向ベクトル
    uniform float u_radius;         // 本体セグメントの半径
    uniform vec2  u_resolution;     // 画面サイズ
    uniform float u_time;           // 秒

    uniform int   u_body_count;     // 本体のセグメント数
    uniform int   u_segment_count;  // 本体＋ヒレ全部のセグメント数
    uniform vec2  u_segments[MAX_SEGMENTS]; // すべてのセグメント座標

    out vec4 outColor;

    void main() {
      vec2 uv = gl_FragCoord.xy / u_resolution;
      vec3 col = vec3(0.0);

      // ====================
      // 1) 本体＋ヒレの描画
      // ====================
      float body_denom = max(float(u_body_count - 1), 1.0);
      float fin_total  = max(float(u_segment_count - u_body_count), 1.0);

      for (int i = 0; i < MAX_SEGMENTS; ++i) {
        if (i >= u_segment_count) break;

        vec2 seg = u_segments[i];
        float d = distance(uv, seg);

        if (i < u_body_count) {
          // 本体
          float body = 1.0 - smoothstep(0.0, u_radius, d);
          float shade = 1.0 - float(i) / body_denom; // 尾ほど少し暗い
          col += vec3(body * shade);
        } else {
          // ヒレ用の小さい蛇
          float local_radius = u_radius * 0.4;
          float fin = 1.0 - smoothstep(0.0, local_radius, d);

          float fin_idx  = float(i - u_body_count);
          float fin_shade = 0.4 + 0.6 * (1.0 - fin_idx / fin_total);
          vec3 fin_color = vec3(0.05, 0.1, 0.3) * fin_shade;

          col += fin * fin_color;
        }
      }

      // ============================
      // 2) 頭の方向マーカー（前・右・左）
      // ============================
      vec2 center = u_mouse;
      vec2 dir    = normalize(u_dir);

      vec2 right_dir = vec2(dir.y, -dir.x);
      vec2 left_dir  = vec2(-dir.y, dir.x);

      vec2 forward = center + dir       * u_radius;
      vec2 right   = center + right_dir * u_radius;
      vec2 left    = center + left_dir  * u_radius;

      float pf = 1.0 - smoothstep(0.0, 0.02, distance(uv, forward));
      float pr = 1.0 - smoothstep(0.0, 0.02, distance(uv, right));
      float pl = 1.0 - smoothstep(0.0, 0.02, distance(uv, left));

      col += vec3(pf, 0.0, 0.0);   // 正面 → 赤
      col += vec3(0.0, pr, 0.0);   // 右   → 緑
      col += vec3(0.0, 0.0, pl);   // 左   → 青

      outColor = vec4(col, 1.0);
    }
  </script>

  <script type="text/javascript">
    function createProgram(gl, vertexSrc, fragmentSrc) {
      let vshd = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vshd, vertexSrc);
      gl.compileShader(vshd);
      if (!gl.getShaderParameter(vshd, gl.COMPILE_STATUS))
        throw new Error("VS compile error: " + gl.getShaderInfoLog(vshd));

      let fshd = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fshd, fragmentSrc);
      gl.compileShader(fshd);
      if (!gl.getShaderParameter(fshd, gl.COMPILE_STATUS))
        throw new Error("FS compile error: " + gl.getShaderInfoLog(fshd));

      let prog = gl.createProgram();
      gl.attachShader(prog, vshd);
      gl.attachShader(prog, fshd);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
        throw new Error("Link error: " + gl.getProgramInfoLog(prog));
      return prog;
    }

    function init() {
      const c  = document.getElementById("glCanvas");
      const gl = c.getContext('webgl2');
      if (!gl) throw new Error("WebGL2 unsupported");

      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      // フルスクリーンクアッド
      const vertexPosBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
      const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const vs = document.querySelector("#vertex-shader").text.trim();
      const fs = document.querySelector("#fragment-shader").text.trim();
      const program = createProgram(gl, vs, fs);
      gl.useProgram(program);

      program.vertexPosAttrib = gl.getAttribLocation(program, "pos");

      // === uniform locations ===
      const u_radius_loc        = gl.getUniformLocation(program, "u_radius");
      const u_resolution_loc    = gl.getUniformLocation(program, "u_resolution");
      const u_mouse_loc         = gl.getUniformLocation(program, "u_mouse");
      const u_dir_loc           = gl.getUniformLocation(program, "u_dir");
      const u_time_loc          = gl.getUniformLocation(program, "u_time");
      const u_segments_loc      = gl.getUniformLocation(program, "u_segments[0]");
      const u_body_count_loc    = gl.getUniformLocation(program, "u_body_count");
      const u_segment_count_loc = gl.getUniformLocation(program, "u_segment_count");

      gl.uniform1f(u_radius_loc, 0.05);
      gl.uniform2f(u_resolution_loc, gl.drawingBufferWidth, gl.drawingBufferHeight);

      // === マウス & 方向 ===
      let mouse_loc      = { x: 0.5, y: 0.5 };
      let mouse_loc_prev = { x: 0.5, y: 0.5 };
      let direction      = { x: 0.0, y: 1.0 }; // 上向き初期

      function onMouseMove(event) {
        mouse_loc_prev.x = mouse_loc.x;
        mouse_loc_prev.y = mouse_loc.y;

        mouse_loc.x = event.clientX / c.width;
        mouse_loc.y = 1.0 - (event.clientY / c.height);

        const raw_dx  = mouse_loc.x - mouse_loc_prev.x;
        const raw_dy  = mouse_loc.y - mouse_loc_prev.y;
        const raw_len = Math.hypot(raw_dx, raw_dy);

        if (raw_len > 1e-4) {
          const raw_dir_x = raw_dx / raw_len;
          const raw_dir_y = raw_dy / raw_len;

          const alpha = 0.2; // スムージング
          direction.x = (1.0 - alpha) * direction.x + alpha * raw_dir_x;
          direction.y = (1.0 - alpha) * direction.y + alpha * raw_dir_y;

          const dlen = Math.hypot(direction.x, direction.y);
          if (dlen > 1e-6) {
            direction.x /= dlen;
            direction.y /= dlen;
          }
        }
      }
      c.addEventListener("mousemove", onMouseMove);

      // === 本体ヘビ ===
      const body_count        =30;
      const body_seg_distance = 0.015;

      let body_positions = [];
      for (let i = 0; i < body_count; i++) {
        body_positions.push({
          x: 0.5 - i * body_seg_distance,
          y: 0.5
        });
      }

      // === ヒレ用の小さな蛇たち ===
      const fin_chain_count        = 20;   // ヒレの本数
      const fin_segments_per_chain = 20;   // 各ヒレの長さ
      const fin_seg_distance       = 0.01;

      let fin_positions = [];
      let fin_phase     = [];
      let fin_prev_positions = [];

      for (let f = 0; f < fin_chain_count; f++) {
        fin_phase.push(Math.random() * Math.PI * 2.0);

        let arr = [];
        let arr_prev = [];
        for (let j = 0; j < fin_segments_per_chain; j++) {
          const x0 = body_positions[body_count - 1].x;
          const y0 = body_positions[body_count - 1].y;
          arr.push({ x: x0, y: y0 });
          arr_prev.push({ x: x0, y: y0 });   // ★前フレームも同じで初期化
        }
        fin_positions.push(arr);
        fin_prev_positions.push(arr_prev);   // ★追加
      }

      const total_segments = body_count + fin_chain_count * fin_segments_per_chain;

      if (total_segments > 256) {
        console.warn("Too many segments for MAX_SEGMENTS");
      }

      // === 本体＋ヒレを更新して uniform に送る ===
      function update_snake_and_fins(time_sec) {
          for (let f = 0; f < fin_chain_count; f++) {
            for (let j = 0; j < fin_segments_per_chain; j++) {
              fin_prev_positions[f][j].x = fin_positions[f][j].x;
              fin_prev_positions[f][j].y = fin_positions[f][j].y;
            }
          }
        // 頭はマウス位置
        body_positions[0].x = mouse_loc.x;
        body_positions[0].y = mouse_loc.y;

        // 本体：前のセグメントから一定距離
        for (let i = 1; i < body_count; i++) {
          const prev = body_positions[i - 1];
          const curr = body_positions[i];

          let vx = curr.x - prev.x;
          let vy = curr.y - prev.y;
          const dist = Math.hypot(vx, vy);

          if (dist < 1e-6) {
            body_positions[i].x = prev.x;
            body_positions[i].y = prev.y;
          } else {
            const t = body_seg_distance / dist;
            body_positions[i].x = prev.x + vx * t;
            body_positions[i].y = prev.y + vy * t;
          }
        }

        // 尻尾の向きと法線
        const parentIndex = body_count - 11;
        const parentPos   = body_positions[parentIndex];


        // ====== ヒレチェーンの更新（チェーン追従だけにする） ======
        for (let f = 0; f < fin_chain_count; f++) {
          // 根元は必ず「親の胴体セグメント」に固定
          fin_positions[f][0].x = parentPos.x;
          fin_positions[f][0].y = parentPos.y;

          // それ以降は胴体と同じロジックで「前の節から一定距離」にそろえる
          for (let j = 1; j < fin_segments_per_chain; j++) {
            const prev = fin_positions[f][j - 1];
            const curr = fin_positions[f][j];

            let vx = curr.x - prev.x;
            let vy = curr.y - prev.y;
            const dist = Math.hypot(vx, vy);

            if (dist < 1e-6) {
              fin_positions[f][j].x = prev.x;
              fin_positions[f][j].y = prev.y;
            } else {
              const t = fin_seg_distance / dist;
              fin_positions[f][j].x = prev.x + vx * t;
              fin_positions[f][j].y = prev.y + vy * t;
            }
          }
        }
        // ====== ひらめき（サイン波オフセット）を追加 ======
      const base_amp   = 0.005; // 揺れの最大振幅（UV空間）※小さめから調整
      const base_speed = 0.4;   // 揺れの速さ

      for (let f = 0; f < fin_chain_count; f++) {
        const phase = fin_phase[f];
        const side  = (f % 2 === 0) ? 1.0 : -1.0; // 左右に揺れの向きを変える

        // 根元(j=0)は触らない（親にガチ固定のまま）
        for (let j = 1; j < fin_segments_per_chain; j++) {
          const prev = fin_positions[f][j - 1];
          const curr = fin_positions[f][j];

          // ローカル方向（このセグメントがどっち向きについているか）
          let dx = curr.x - prev.x;
          let dy = curr.y - prev.y;
          const len = Math.hypot(dx, dy);
          if (len < 1e-6) continue;
          dx /= len;
          dy /= len;

          // ローカル法線（チェーンに対して直角方向）
          let nx = -dy;
          let ny =  dx;

          // 0〜1（根元0, 先端1）
          const t = j / (fin_segments_per_chain - 1);

          // 先端ほどよく動くように振幅をスケール
          const amp   = base_amp * t;
          const omega = base_speed;

          // 時間＋節番号＋フィンごと位相でサイン波
          const w = Math.sin(omega * time_sec + phase + t * 4.0);

          // サイン波オフセット（左右を side で分ける）
          const offset = w * amp * side;

          fin_positions[f][j].x += nx * offset;
          fin_positions[f][j].y += ny * offset;
        }
      }



        // 本体＋ヒレを 1 本の配列にまとめて GPU へ送る
        const segment_data = new Float32Array(total_segments * 2);
        let idx = 0;

        for (let i = 0; i < body_count; i++) {
          segment_data[idx * 2 + 0] = body_positions[i].x;
          segment_data[idx * 2 + 1] = body_positions[i].y;
          idx++;
        }

        for (let f = 0; f < fin_chain_count; f++) {
          for (let j = 0; j < fin_segments_per_chain; j++) {
            segment_data[idx * 2 + 0] = fin_positions[f][j].x;
            segment_data[idx * 2 + 1] = fin_positions[f][j].y;
            idx++;
          }
        }

        gl.useProgram(program);
        gl.uniform1i(u_body_count_loc, body_count);
        gl.uniform1i(u_segment_count_loc, total_segments);
        gl.uniform2fv(u_segments_loc, segment_data);
      }

      // === レンダリングループ ===
      function render(time_ms) {
        const time_sec = time_ms * 0.001;

        // uniform 更新
        gl.useProgram(program);
        gl.uniform1f(u_time_loc, time_sec);
        gl.uniform2f(u_mouse_loc, mouse_loc.x, mouse_loc.y);
        gl.uniform2f(u_dir_loc,   direction.x,  direction.y);

        update_snake_and_fins(time_sec);

        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enableVertexAttribArray(program.vertexPosAttrib);
        gl.vertexAttribPointer(program.vertexPosAttrib, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    }

    window.onload = init;
  </script>
</body>
</html>
