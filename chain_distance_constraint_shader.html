<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Distance-Constrained Chain — Per-Node Ring Sizes (WebGL2)</title>
<style>
  html, body { margin:0; height:100%; background:#0b0e12; color:#e6edf5; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  #wrap { position:relative; width:100%; height:100%; }
  canvas { width:100%; height:100%; display:block; }
  #hud { position:absolute; left:12px; top:10px; font-size:14px; line-height:1.4; pointer-events:none; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="gl"></canvas>
  <div id="hud">
    <div><strong>Per-Node Ring Sizes — 固定値</strong></div>
    <div>・先頭ノードはマウス位置に固定（物理は従来通り）</div>
    <div>・各ノードのリング直径はコード内の配列で指定</div>
  </div>
</div>

<script>
(function() {
  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl2', {antialias:true});
  if (!gl) { alert('WebGL2 が必要です'); return; }

  function resize() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
      gl.viewport(0, 0, w, h);
    }
  }
  window.addEventListener('resize', resize, false);
  resize();

  const extCF = gl.getExtension('EXT_color_buffer_float');
  if (!extCF) console.warn('EXT_color_buffer_float not available; using RGBA16F for FBOs');

  // ---- Parameters ----
  const COUNT   = 8;           // number of nodes
  const SEGLEN  = 70.0;       // distance constraint (pixels)
  const SUBSTEPS= 8;           // simulation passes per frame
  const EDGE_PX = 8.0;         // 縁の太さ（全ノード共通, ピクセル）

  // ★ 各ノードのリング直径（ピクセル）を定義（先頭=0）
  //   必要に応じて値を変更してください。
  const sizesPx = [
    64,   // node 0
    100,   // node 1
    100,
    96,   // node 2
    72,
    60,
    56,
    32
  ];

  // --- position textures (ping-pong) ---
  function makePosTex() {
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    const internalFormat = extCF ? gl.RGBA32F : gl.RGBA16F;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, COUNT, 1, 0, gl.RGBA, extCF ? gl.FLOAT : gl.HALF_FLOAT, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return tex;
  }
  function makeFBO(tex) {
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    const ok = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    if (!ok) console.error('Framebuffer incomplete');
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return fb;
  }
  const texA = makePosTex();
  const texB = makePosTex();
  const fboA = makeFBO(texA);
  const fboB = makeFBO(texB);

  // --- sizes texture (read-only; width=COUNT, RGBA32F, size in .x) ---
  const sizeTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, sizeTex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  // store as RGBA32F for portability
  const sizeData = new Float32Array(COUNT * 4);
  for (let i = 0; i < COUNT; i++) {
    sizeData[i*4+0] = sizesPx[i]; // .r = diameter in px
    sizeData[i*4+1] = 0.0;
    sizeData[i*4+2] = 0.0;
    sizeData[i*4+3] = 1.0;
  }
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, COUNT, 1, 0, gl.RGBA, gl.FLOAT, sizeData);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // --- initialize positions into texA ---
  function initPositions() {
    const w = canvas.width, h = canvas.height;
    const data = new Float32Array(COUNT * 4);
    const cx = Math.floor(w * 0.35), cy = Math.floor(h * 0.5);
    for (let i = 0; i < COUNT; i++) {
      data[i*4+0] = cx - i * SEGLEN;
      data[i*4+1] = cy;
      data[i*4+2] = 0.0;
      data[i*4+3] = 1.0;
    }
    gl.bindTexture(gl.TEXTURE_2D, texA);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, COUNT, 1, gl.RGBA, gl.FLOAT, data);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
  initPositions();

  // --- shaders ---
  const simVS = `#version 300 es
  precision highp float;
  const vec2 POS[3] = vec2[3](vec2(-1.0,-1.0), vec2(3.0,-1.0), vec2(-1.0,3.0));
  void main(){ gl_Position = vec4(POS[gl_VertexID], 0.0, 1.0); }`;
  const simFS = `#version 300 es
  precision highp float;
  uniform sampler2D u_posTex;
  uniform vec2  u_mouse;
  uniform float u_segLen;
  out vec4 fragColor;
  void main(){
    int idx = int(gl_FragCoord.x);
    if (idx == 0) { fragColor = vec4(u_mouse, 0.0, 1.0); return; }
    vec2 prev = texelFetch(u_posTex, ivec2(idx-1,0), 0).xy;
    vec2 cur  = texelFetch(u_posTex, ivec2(idx,  0), 0).xy;
    vec2 dir = cur - prev;
    float d = length(dir);
    if (d < 1e-6) { dir = vec2(u_segLen, 0.0); d = u_segLen; }
    vec2 nextPos = prev + dir * (u_segLen / d);
    fragColor = vec4(nextPos, 0.0, 1.0);
  }`;

  // Points (rings) with per-node size via texture
  const ptsVS = `#version 300 es
  precision highp float;
  uniform sampler2D u_posTex;
  uniform sampler2D u_sizeTex;   // sizes in .r (pixels, before DPR)
  uniform vec2  u_resolution;
  uniform float u_dpr;           // devicePixelRatio clamp
  out float v_index;
  out float v_psize;             // actual gl_PointSize (pixels)
  void main(){
    int idx = gl_VertexID;
    vec2 pos = texelFetch(u_posTex, ivec2(idx,0), 0).xy;
    float diameterPx = texelFetch(u_sizeTex, ivec2(idx,0), 0).r; // px (not scaled by DPR)
    vec2 ndc = (pos / u_resolution) * 2.0 - 1.0; ndc.y = -ndc.y;
    float psize = max(diameterPx, 1.0) * u_dpr;
    gl_Position = vec4(ndc, 0.0, 1.0);
    gl_PointSize = psize;
    v_psize = psize;
    v_index = float(idx);
  }`;
  const ptsFS = `#version 300 es
  precision highp float;
  in float v_index;
  in float v_psize;
  uniform float u_edgePx;        // edge thickness (px), after DPR
  out vec4 fragColor;
  void main(){
    vec2 p = gl_PointCoord * 2.0 - 1.0;
    float r = length(p);
    if (r > 1.0) discard;
    float t_norm = clamp(2.0 * u_edgePx / max(v_psize, 1.0), 0.0, 1.0);
    float edge = smoothstep(1.0 - t_norm, 1.0, r);
    vec3 col = (v_index < 0.5) ? vec3(0.47, 0.78, 1.0) : vec3(0.92);
    fragColor = vec4(col, edge);
  }`;

  function compile(type, src) {
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(sh));
      throw new Error('Shader compile failed');
    }
    return sh;
  }
  function link(vs, fs) {
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(prog));
      throw new Error('Program link failed');
    }
    return prog;
  }
  const simProg = link(compile(gl.VERTEX_SHADER, simVS), compile(gl.FRAGMENT_SHADER, simFS));
  const ptsProg = link(compile(gl.VERTEX_SHADER, ptsVS), compile(gl.FRAGMENT_SHADER, ptsFS));

  // mouse
  let mouse = { x: canvas.width * 0.5, y: canvas.height * 0.5 };
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    mouse.x = (e.clientX - rect.left) * dpr;
    mouse.y = (e.clientY - rect.top)  * dpr;
  });

  // VAOs
  const fsqVAO   = gl.createVertexArray();
  const pointsVAO= gl.createVertexArray();

  function step() {
    resize();

    // simulation ping-pong
    let readTex = texA, writeFBO = fboB;
    for (let s = 0; s < SUBSTEPS; s++) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, writeFBO);
      gl.viewport(0, 0, COUNT, 1);
      gl.useProgram(simProg);
      gl.bindVertexArray(fsqVAO);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, readTex);
      gl.uniform1i(gl.getUniformLocation(simProg, 'u_posTex'), 0);
      gl.uniform2f(gl.getUniformLocation(simProg, 'u_mouse'), mouse.x, mouse.y);
      gl.uniform1f(gl.getUniformLocation(simProg, 'u_segLen'), SEGLEN);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      gl.bindVertexArray(null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      if (writeFBO === fboB) { writeFBO = fboA; readTex = texB; }
      else { writeFBO = fboB; readTex = texA; }
    }
    const curTex = (readTex === texA) ? texB : texA;

    // draw
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.043, 0.055, 0.071, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.useProgram(ptsProg);
    gl.bindVertexArray(pointsVAO);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, curTex);
    gl.uniform1i(gl.getUniformLocation(ptsProg, 'u_posTex'), 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, sizeTex);
    gl.uniform1i(gl.getUniformLocation(ptsProg, 'u_sizeTex'), 1);

    gl.uniform2f(gl.getUniformLocation(ptsProg, 'u_resolution'), canvas.width, canvas.height);
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    gl.uniform1f(gl.getUniformLocation(ptsProg, 'u_dpr'), dpr);
    gl.uniform1f(gl.getUniformLocation(ptsProg, 'u_edgePx'), EDGE_PX * dpr);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.drawArrays(gl.POINTS, 0, COUNT);
    gl.disable(gl.BLEND);
    gl.bindVertexArray(null);

    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
